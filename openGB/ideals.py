import numpy as np

import openGB.polynomials as polys



class IdealException(Exception):
    def __init__(self,msg):
        self.msg=msg
        
    def __str__(self):
        return "IdealException: " + self.msg
    
class IdealCoefficinentMismatchException(IdealException):
    def __init__(self,msg):
        super(IdealException, self).__init__(msg)
        
    def __str__(self):
        return "IdealCoefficinentMismatchException: " + self.msg
    

class Ideal:
    '''
    Ideals generated by set of polynomials    
    '''
    def __init__(self, polynomials, order, vars):
        '''
        Parameters
        Polynomial[] polynomials -- a sequence of polynomials
        MonomialOrder order -- a monomial order applied to the polynomials
        '''
        self.polynomials = polynomials
        self.order = order
        self.isGB = False
        self.vars = vars

    def sort(self):
        '''
        Sorts all monomials in polynomials
        '''
        for i in np.arange(len(self.polynomials)):
            self.polynomials[i].sort()
            
    def getInTerms(self):
        '''
        Gives a set of initial terms
        
        Returns
        Monomial[] mons
        '''
        return [poly.inTerm() for poly in self.polynomials]

    #a fancy-looking string representation
    def __str__(self):
        return "( "+",\n".join([str(poly) for poly in self.polynomials])+" )"
    
    def getComb(self,polys):
        '''
        Computes a polynomial combination
        
        Input
        Polynomial[] polys -- list of polynomial coefficients
        
        Returns
        Polynomial poly
        '''
        if(len(self.polynomials)==len(polys)):
            polyFinal = sum([polys[i]*self.polynomials[i] for i in np.arange(len(self.polynomials))])
            polyFinal.simplify()
        else:
            raise IdealCoefficinentMismatchException("Wrong number of coffiecients in polynomial combination")
        return polyFinal

    def checkGB(self):
        '''
        Checks if the set of polynomials forms a GB
        '''
        pass

    def computeGB(self):
        '''
        Computes a Groebner Basis using Buchberger algorithm
        '''
        #S-pairs etc
        pass
    
    
    def baseReduce(self, p1):
        '''
        Reduces with self.polynomials as much as possible
        
        Input
        Polynomial p1 -- what to reduce
        
        Returns
        Polynomial poly
        '''
        while(True):
            for poly in self.polynomials:
                p1,suc = self.reduce(p1,poly)
                if(suc):
                    break
            else:
                return p1
            
    
    def reduce(self, p1, p2):
        '''
        Reduces p1 with p2 as much as possible
        
        Input
        Polynomial p1 -- what to reduce
        Polynomial p2 -- reducer
        
        Returns
        Polynomial poly
        '''
        in2 = p2.inTerm()
        success=False
        while(True):
            try:
                firstDiv = np.where([np.all((mon.deg-in2.deg)>=0) for mon in p1.monomials])[0][0]
            except:
                break
            polyMon = polys.Monomial(deg=p1.monomials[firstDiv].deg-in2.deg, coef=p1.monomials[firstDiv].coef/in2.coef,
                                     order=self.order, vars=self.vars).toPolynomial()
            p1 = p1 - polyMon*p2
            success=True
        return p1, success
    
        
            
        
